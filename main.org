#+TITLE: Recursive Lang
#+AUTHOR: Subhajit Sahu (2018801013)



* Imports

In recursive language, identifiers are anything other than brackets,
keywords, numbers, or booleans. Alphabet checking is no more used, so
symbols can now be identifiers as well.

#+NAME: imports
#+BEGIN_SRC haskell
import Data.List
import System.IO
import qualified Data.Map as Map
#+END_SRC



* Values

Expressible values now include functions =Procv=. These take as input,
their lexical environment, formals (as identifers), and body. The recursive
functions are treated specially here =Recuv=. They additionally take as
input (second) the binding environment, which is not circular (yet).

#+NAME: data_value
#+BEGIN_SRC haskell
data Value =
  Numv  Float  |
  Boolv Bool   |
  Procv Env [Ast] Ast |
  Recuv Env Env [Ast] Ast
  deriving (Eq)

instance Show Value where
  show (Numv x)  = show x
  show (Boolv x) = show x
  show (Procv _ _ _) = "#<procedure>"
  show (Recuv _ _ _ _) = "#<procedure>"

instance Num Value where
  (Numv x) + (Numv y) = Numv $ x + y
  (Numv x) * (Numv y) = Numv $ x * y
  abs (Numv x)    = Numv $ abs x
  signum (Numv x) = Numv $ signum x
  fromInteger x   = Numv $ fromInteger x
  negate (Numv x) = Numv $ negate x

instance Fractional Value where
  (Numv x) / (Numv y) = Numv $ x / y
  fromRational x = Numv $ fromRational x
#+END_SRC



* Abstract Syntax Tree

The AST now additionally includes primitive functions, such as =zero?=,
which are no more keywords, but predefined identifers. The =Primv=
acts as the **body** of a procedure =Procv= and takes as input the
string name of the primitive function it represents. The AST evaluator
then based on the string, performs the desired primitive operation.

The =Function= node takes as input the formals and body. Function
application =Apply= takes an expression and the parameters. Since
=Recfun= defines a number if recursive procedures, it takes an list
of identifiers, formals, and bodies. Finally, the =if= keyword is
renamed to =ifte=.

#+NAME: data_ast
#+BEGIN_SRC haskell
  Numa   Float   |
  Boola  Bool    |
  Ida    String  |
  Primv  String  |
  Ifte      Ast Ast Ast      |
  Assume    [(Ast, Ast)] Ast |
  Function  [Ast] Ast        |
  Recfun    [(Ast, [Ast], Ast)] Ast |
  Apply     Ast [Ast]
#+END_SRC



* Environment

The environment, as before, is simply a =String= to =Value= map.

#+NAME: type_env
#+BEGIN_SRC haskell
type Env = Map.Map String Value
#+END_SRC



* Run

The =main= function as before provides the REPL. It simply accepts a line
and shows the output =Value= of =run= function. Use an empty (null) line to
terminate.

#+NAME: main
#+BEGIN_SRC haskell
main = do
  putStr "recursive: "
  hFlush stdout
  exp <- getLine
  if null exp
    then return ()
    else do
      putStrLn (show . run $ exp)
      main
#+END_SRC

The run function now simply parses and evaluates a string with an environment
populated with primitive procedures. Each primitive procedure takes as input
formals =x= and optionally =y=.

#+NAME: run
#+BEGIN_SRC haskell
run :: String -> Value
run = (eval $ Map.fromList def) . parse
  where def = map f ops
        f s = (s, Procv m fs $ Primv s)
        ops = ["+", "*", "-", "/", "=", "&", "|", "~", "zero?"]
        fs = [Ida "x", Ida "y"]
        m = Map.empty
#+END_SRC



* Evaluator

The =eval= function now pattern matches against =Primv= for primitive bodies.
Each primitive function "gets" its formals from its environemnt. Same is true
for custom functions. As before, =Assume= is executing the body in a new
environment, which is a union of bindings (from =elaborate=) and the current
environment.

A =Function= simply evaluates to a procedure, which is an expressible value.


#+NAME: eval
#+BEGIN_SRC haskell
eval :: Env -> Ast -> Value
eval _ (Numa  x) = Numv  x
eval _ (Boola x) = Boolv x
eval m (Ida x)   = get m x
eval m (Primv "+") = (get m "x") + (get m "y")
eval m (Primv "*") = (get m "x") * (get m "y")
eval m (Primv "-") = (get m "x") - (get m "y")
eval m (Primv "/") = (get m "x") / (get m "y")
eval m (Primv "=") = Boolv $ get m "x" == get m "y"
eval m (Primv "&") = Boolv $ get m "x" == Boolv True && get m "y" == Boolv True
eval m (Primv "|") = Boolv $ get m "x" == Boolv True || get m "y" == Boolv True
eval m (Primv "~") = Boolv $ if get m "x" == Boolv True then False else True
eval m (Primv "zero?")  = Boolv $ get m "x" == Numv 0
eval m (Ifte c t e)       = if eval m c == Boolv True then eval m t else eval m e
eval m (Assume bs x)    = eval m' x
  where m' = Map.union mb m
        mb = elaborate m bs
eval m (Function fs b)  = Procv m fs b
eval m (Recfun ps x) = eval m' x
  where m' = Map.union mb m
        mb = recurse . elaborate m . map f $ ps
        f (l, fs, b) = (l, Function fs b)
eval m (Apply x ps)     = eval m' b
  where m' = Map.union mf ml
        mf = elaborate m $ zip fs ps
        (Procv ml fs b) = unrecurse $ eval m x
#+END_SRC

The =elaborate= takes the current environment (for eval), the bindings,
and returns a new environment only from the bindings. This environment
needs to be composed with the current environment, as is done before.

#+NAME: elaborate
#+BEGIN_SRC haskell
elaborate :: Env -> [(Ast, Ast)] -> Env
elaborate m =  Map.fromList . map f
  where f (Ida x, e) = (x, eval m e)
#+END_SRC

The =fetch= does a lookup on the environment, which is a map, and if not
available throws an error.

#+NAME: fetch
#+BEGIN_SRC haskell
fetch :: Env -> String -> Value
fetch m id = case v of
    (Just x) -> x
    Nothing  -> error $ "id " ++ id ++ " not set!"
  where v = Map.lookup id m
#+END_SRC




* Parser

As before, i wanted to depend upon the =read= function to generate the AST.
While its simple for =Ida=, =And=, =Or=, =Not=, =If=, unfortunately
it is not like that for =Assume=. In order for =Assume= to accept an array
of pairs (tuples) as bindings, the first bracket needs to be square (for array)
and the second needs to be round (for pair). Additionally, each item needs to
be separated by comma, and not just space.

In order to perform this alteration, the whole input string is converted to
words, which is then converted to a hierarchical bracket tree. All alterations
are performed upon this bracket tree. Finally, the bracket tree is converted to
a string which can then be directly parsed through =read= function.

Also we dont distinguish between square and round brackets, just like in racket,
so square brackets are simply replaced with round brackets.

#+NAME: parse
#+BEGIN_SRC haskell
parse :: String -> Ast
parse s = (read . unwords . unpack . alter . Bnode "" . pack . words $ bpad) :: Ast
  where bpad = replace "(" " ( " . replace ")" " ) " . replace "[" "(" . replace "]" ")" $ s
#+END_SRC

Here is the alteration strategy strategy.

#+NAME: alter
#+BEGIN_SRC haskell
alter :: Btree -> Btree
alter (Bnode _ (Bleaf "assume":ns)) = (Bnode "(" (Bleaf "Assume":ns'))
  where (Bnode _ binds):exps = ns
        ns' = (Bnode "[" binds'):exps'
        binds' = intersperse comma . map toPair $ binds
        toPair (Bnode _ xv) = Bnode "(" . intersperse comma . map alter $ xv
        exps' = map alter exps
        comma = Bleaf ","
alter (Bnode b ns) = Bnode b $ map alter ns
alter (Bleaf w) = Bleaf $ case w of
  "+" -> "Add"
  "*" -> "Mul"
  "-" -> "Sub"
  "/" -> "Div"
  "=" -> "Equals"
  "&" -> "And"
  "|" -> "Or"
  "~" -> "Not"
  "zero?" -> "IsZero"
  "if" -> "If"
  w
    | isFloat w  -> "(Numa "  ++ w ++ ")"
    | isBool  w  -> "(Boola " ++ w ++ ")"
    | isId    w  -> "(Ida \""   ++ w ++ "\")"
    | otherwise  -> w
#+END_SRC

Here are bracket tree functions, for converting words to bracket trees and
vice versa.

#+NAME: btree
#+BEGIN_SRC haskell
data Btree =
  Bnode String [Btree] |
  Bleaf String
  deriving (Eq, Read, Show)

unpack :: Btree -> [String]
unpack (Bleaf w)  = [w]
unpack (Bnode b ns) = b : (foldr (++) [b'] $ map unpack ns)
  where b' = if b == "[" then "]" else (if b == "(" then ")" else "")

pack :: [String] -> [Btree]
pack [] = []
pack all@(w:ws)
  | isClose = []
  | isOpen  = node : pack ws'
  | otherwise = Bleaf w : pack ws
  where isOpen  = w == "[" || w == "("
        isClose = w == "]" || w == ")"
        node = Bnode w $ pack ws
        ws' = drop (area node) all
        win = pack ws

area :: Btree -> Int
area (Bleaf _) = 1
area (Bnode _ ns) = foldr (+) 2 $ map area ns
#+END_SRC

And, here are a few utility functions we are using.

#+NAME: utility
#+BEGIN_SRC haskell
replace :: (Eq a) => [a] -> [a] -> [a] -> [a]
replace _ _ [] = []
replace from to all@(x:xs)
  | from `isPrefixOf` all = to ++ (replace from to . drop (length from) $ all)
  | otherwise             = x : replace from to xs

isFloat :: String -> Bool
isFloat s = case (reads s) :: [(Float, String)] of
  [(_, "")] -> True
  _         -> False

isBool :: String -> Bool
isBool s = case (reads s) :: [(Bool, String)] of
  [(_, "")] -> True
  _         -> False

isId :: String -> Bool
isId (c:cs) = isAlpha c && all isAlphaNum cs
#+END_SRC



* This is where you put it all together

#+BEGIN_SRC haskell :eval no :noweb yes :tangle lexical.hs
<<imports>>


<<data_value>>


<<data_ast>>

<<type_env>>

<<main>>

<<run>>

<<eval>>

<<elaborate>>

<<fetch>>


<<parse>>

<<alter>>


<<btree>>


<<utility>>
#+END_SRC
